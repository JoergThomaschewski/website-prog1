# 4.6.5 Struktur durch klare Methoden und Klassen â€“ Prinzip der Verantwortung

In der objektorientierten Programmierung ist es ein wichtiges Prinzip: **eine Methode â€“ eine Aufgabe**. Das bedeutet: Jede Methode soll genau fÃ¼r das zustÃ¤ndig sein, was ihr Name verspricht â€“ **nicht mehr und nicht weniger**.

Das erhÃ¶ht die Lesbarkeit, erleichtert spÃ¤tere Ã„nderungen und fÃ¶rdert **sauberen Code** (â€Clean Codeâ€œ). Dieses Prinzip wird auch als **Single Responsibility Principle** bezeichnet.

---

## ğŸš² Beispiel: Fahrrad mit klaren ZustÃ¤ndigkeiten

Wir bauen eine Klasse `Fahrrad`, die genau zwei Methoden hat:

- `fahren()` verÃ¤ndert den Zustand (mehr Kilometer)
- `zeigeKm()` zeigt den aktuellen Kilometerstand


```python linenums="1"
# Fahrrad-Klasse mit geschÃ¼tzten Attributen
# J. Thomaschewski, 29.07.2025

class Fahrrad:
    def __init__(self):
        self.__km = 0

    def fahren(self, strecke):
        self.__km += strecke

    def zeigeKm(self):
        print(f"Gefahrene Kilometer: {self.__km}")

# Hauptprogramm
bike = Fahrrad()
bike.fahren(12)
bike.zeigeKm()
```

Ausgabe:<br>
*Gefahrene Kilometer: 12*

---

## ğŸ’¡ Guter Stil â€“ Praktisches Beispiel mit Display

In dieser Ãœbung prÃ¼fen wir die TextlÃ¤nge, bevor etwas auf ein OLED-Display ausgegeben wird. Die **Logik** wird dabei sauber von der **Anzeige** getrennt. Auch hier nutzen wir private Attribute im CamelCase-Stil.

```python linenums="1"
# TextlÃ¤nge prÃ¼fen und anzeigen (OLED)
# Praktikumsbeispiel â€“ J. Thomaschewski, 29.07.2025

from machine import Pin, SoftI2C
from ssd1306 import SSD1306_I2C

# OLED initialisieren
i2c = SoftI2C(scl=Pin(17), sda=Pin(16))
oled = SSD1306_I2C(128, 64, i2c, addr=0x3C)

class Eingabe:
    def __init__(self, maxLaenge):
        self.__maxLaenge = maxLaenge

    def pruefeText(self, text):
        if len(text) <= self.__maxLaenge:
            return text
        else:
            return "Text ist zu lang!"

# Hauptprogramm
eingabe = Eingabe(16)
text = input("Gib deinen Text ein: ")
anzeigeText = eingabe.pruefeText(text)

oled.fill(0)
oled.text(anzeigeText, 0, 20)
oled.show()
```

---

!!! quote "Wichtig"
    **ğŸ§  Merksatz: Eine Methode soll eine Aufgabe haben.** Wenn wir beim ErklÃ¤ren einer Methode das Wort â€undâ€œ verwenden, ist sie wahrscheinlich zu lang oder falsch aufgeteilt.



!!! question "Aufgabe â€“ Methoden aufteilen"
    ErgÃ¤nze die Klasse `Fahrrad` um eine Methode `resetKm()`, die den Kilometerstand wieder auf null setzt. Gib den Kilometerstand vor und nach dem Reset aus.

    ??? example "LÃ¶sungsvorschlag"
        ```python linenums="1"
        class Fahrrad:
            def __init__(self):
                self.__km = 0

            def fahren(self, strecke):
                self.__km += strecke

            def zeigeKm(self):
                print(f"Gefahrene Kilometer: {self.__km}")

            def resetKm(self):
                self.__km = 0

        bike = Fahrrad()
        bike.fahren(25)
        bike.zeigeKm()
        bike.resetKm()
        bike.zeigeKm()
        ```

        Ausgabe:<br>
        *Gefahrene Kilometer: 25*  
        *Gefahrene Kilometer: 0*


---

## ğŸ” Strukturierung von Klassen â€“ was eine gute Klasse ausmacht

Nachdem wir uns mit dem Aufbau und der ZustÃ¤ndigkeit einzelner Methoden beschÃ¤ftigt haben, wollen wir jetzt betrachten, **was eine gut strukturierte Klasse ausmacht**.

Eine Klasse sollte so gestaltet sein, dass sie:

- **eine klar umrissene Aufgabe** erfÃ¼llt,
- **alle notwendigen Daten (Attribute)** zur Bearbeitung dieser Aufgabe enthÃ¤lt,
- und **nur Methoden anbietet**, die zum Arbeiten mit genau diesen Daten benÃ¶tigt werden.

Wir sprechen dabei auch von einer **logischen Kapselung**: Daten und Funktionen, die zusammengehÃ¶ren, sollen auch im Code **zusammenbleiben**.

### Beispiele fÃ¼r gut strukturierte Klassen

| Klasse       | Aufgabe                                      | Sinnvolle Methoden                                 |
|--------------|----------------------------------------------|----------------------------------------------------|
| `Konto`      | Kontostand verwalten                         | `einzahlen()`, `abheben()`, `zeigeStand()`         |
| `Fahrrad`    | Gefahrene Kilometer zÃ¤hlen und zurÃ¼cksetzen  | `fahren()`, `zeigeKilometer()`, `zuruecksetzen()`  |
| `Ampel`      | Steuerung eines einfachen Ampelablaufs       | `start()`, `wechsleZuRot()`, `wechsleZuGruen()`    |


Wichtig: Eine Klasse sollte **nicht zu viele unterschiedliche Aufgaben** Ã¼bernehmen. Wenn eine Klasse plÃ¶tzlich **Benutzereingaben verarbeitet**, **LEDs steuert** und **Daten speichert**, ist sie zu breit aufgestellt. Solche Aufgaben gehÃ¶ren in verschiedene Klassen.

!!! quote "Wichtig"
    **ğŸ§  Merksatz: Eine Klasse sollte eine Aufgabe haben â€“ und nur das tun, was zu dieser Aufgabe gehÃ¶rt.**

Wenn wir nun wissen,  was eine gute Klasse ausmacht, gehen wir auf die nÃ¤chste Strukturebene und fassen gleichartige Klassen zusammen. 

## âœ¨ Model - View - Controler (MVC-Konzept)

Das **Model-View-Controller (MVC)**-Konzept ist ein bewÃ¤hrtes Entwurfsmuster in der Softwareentwicklung, das Klassen in drei Gruppen unterteilt:

1. **Model (Modell):** Das Model ist fÃ¼r die Datenhaltung zustÃ¤ndig. Hierin finden sich Klassen zum Speichern und Abrufen der Daten. Da das Model unabhÃ¤ngig von der Verarbeitung der Daten (Controler) und der Ansicht der Daten (View) ist, kann man in einer guten Programmierung die Datenhaltung Ã¤ndern, ohne dass dies einen Einfluss auf die Datenverarbeitung bzw. die Darstellung der Daten hat.

2. **View (Ansicht):** In den Klassen des Views findet die Darstellung der Anwendung sowie die Interaktionen Darstellung der Benutzerinteraktionen statt.

3. **Controller (Steuerung):** Der Controller fungiert als Vermittler zwischen Model und View. Er verarbeitet Benutzereingaben, aktualisiert das Modell entsprechend und sorgt dafÃ¼r, dass die Ansicht die aktuellen Daten anzeigt.

Durch diese Trennung der Verantwortlichkeiten fÃ¶rdert das MVC-Muster eine klare Strukturierung des Codes, erleichtert die Wartung und ermÃ¶glicht eine parallele Entwicklung der einzelnen Komponenten. In Python wird dieses Muster hÃ¤ufig in Web-Frameworks wie Django verwendet, um eine saubere und skalierbare Anwendungsarchitektur zu gewÃ¤hrleisten. 
