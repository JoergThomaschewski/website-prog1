# 4.5.4 Objektstruktur & Kapselung mit privaten Attributen

In Python verwenden wir **Attribute**, um den Zustand eines Objekts zu beschreiben.  In diesem Kapitel lernen wir, wie wir den Zugriff auf solche Attribute kontrollieren k√∂nnen.


## ü§ñ Zugriff auf Attribute "von au√üen"

In Python k√∂nnen wir auf Attribute eines Objekts einfach mit `objekt.attribut` zugreifen, leider auch aus dem Hauptprogramm, was also **von au√üen** genannt wird.

```python linenums="1"
# Klasse mit √∂ffentlich zug√§nglichem Attribut (unsicher!)
# J. Thomaschewski, 29.07.2025
class Konto:
    def __init__(self):
        self.stand = 100

    def einzahlen(self, betrag):
        if isinstance(betrag, (int, float)) and betrag > 0:
            self.stand += betrag
        else:
            print("Ung√ºltiger Betrag ‚Äì bitte nur positive Zahlen!")

    def zeige(self):
        print('Kontostand: ', self.stand)


# Hauptprogramm
giro = Konto()
giro.zeige()
giro.einzahlen(50)
giro.zeige()

# Manipulation von au√üen (kaputt gemacht!)
giro.stand = "1.000,-- ‚Ç¨"  # Funktioniert formal, aber inhaltlich v√∂lliger Unsinn
giro.zeige()               # Gibt sogar ein Ergebnis aus. Der Fehler kommt erst anschlie√üend.
giro.einzahlen(50)         # Einzahlen geht jetzt nicht mehr. Fehlermeldung erst hier.
giro.zeige()
```

Das "√úberschreiben" der Attribute direkt aus dem Hauptprogramm muss vermieden werden. 



## üõ°Ô∏è Schutz von Attributen

Ein Attribut wird als "privat" markiert, indem wir seinem Namen zwei Unterstriche voranstellen. Das ist n√ºtzlich, wenn wir verhindern m√∂chten, dass jemand von au√üen direkt darauf zugreift.

```python linenums="1"
class Konto:
    def __init__(self):
        self.__stand = 100  # Startwert

    def einzahlen(self, betrag):
        if isinstance(betrag, (int, float)) and betrag > 0:
            self.__stand += betrag
        else:
            print("Ung√ºltiger Betrag ‚Äì bitte nur positive Zahlen!")

    def zeige(self):
        print("Kontostand:", self.__stand)

# Hauptprogramm
giro = Konto()
giro.zeige()
giro.einzahlen(50)
giro.zeige()

# Manipulation von au√üen (geht jetzt nicht mehr)
giro.stand = "1.000,-- ‚Ç¨"  # wird einfach ignoriert. Kein Fehler, sondern einfach nichts.
giro.zeige()              
giro.einzahlen(50)         
giro.zeige()

# Man k√∂nnte noch versuchen
giro.__stand = "1.000,-- ‚Ç¨"  # wird ebenfalls ignoriert. Kein Fehler, sondern einfach nichts.
giro.einzahlen("1.000,-- ‚Ç¨") # gibt die sch√∂ne Fehlermeldung
```

Privat bedeutet hier: Es **soll** nicht direkt von au√üen verwendet werden. Python verhindert dies nicht vollst√§ndig, aber es ist eine wichtige Konvention zur sauberen Programmierung.

!!! info "Privat durch Konvention"

    - `_attribut` (ein Unterstrich) signalisiert: "gesch√ºtztes Attribut, bitte nicht von au√üen verwenden."
    - `__attribut` (zwei Unterstriche) aktiviert das sogenannte *Name Mangling*: Das Attribut wird intern umbenannt, sodass es schwerer zug√§nglich ist.

    Python ist an dieser Stelle "unsch√∂ner" als andere objektorientierte Sprachen wie Java oder PHP, die einen eindeutigen Fehler ausgeben.



## üîí Getter- und Setter-Methoden


In der objektorientierten Programmierung ist es oft vorteilhaft, Attribute einer Klasse nicht direkt zug√§nglich zu machen, sondern den Zugriff √ºber sogenannte Getter- und Setter-Methoden zu steuern. Dies bietet mehrere Vorteile:

- **Datenvalidierung**: Bevor ein Attribut ein Wert zugewiesen wird, kann √ºberpr√ºft werden, ob dieser Wert g√ºltig ist und den erwarteten Kriterien entspricht.

- **Kontrollierter Zugriff**: √ñffentliche Attribute k√∂nnen von √ºberall gelesen und geschrieben werden. Oftmals m√∂chte man jedoch den schreibenden Zugriff einschr√§nken oder an bestimmte Bedingungen kn√ºpfen.

- **Erweiterbarkeit**: Durch die Verwendung von Getter- und Setter-Methoden kann sp√§ter zus√§tzliche Funktionalit√§t hinzugef√ºgt werden, wie z.B. das Beobachter-Pattern, um √Ñnderungen an Eigenschaften an andere Programmteile weiterzuleiten.

Im folgenden Python-Beispiel wird eine Klasse `Student` definiert, die diese Prinzipien anwendet.

```python linenums="1"
class Student:
def **init**(self, name: str, matrNumber: int, phoneNumber: str):
self._name = name
self._matrNumber = matrNumber
self._phoneNumber = phoneNumber

def getMatrNumber(self):
    return self._matrNumber

def getPhoneNumber(self):
    return self._phoneNumber

def setPhoneNumber(self, newPhoneNumber):
    self._phoneNumber = newPhoneNumber

def returnNameAndMatrikel(self):
    return f"{self._name} hat die Matr.-Nr.: {self._matrNumber}"


student = Student("Marie", 7203456, "0491-23403")
print(student.getMatrNumber())
print(student.getPhoneNumber())
student.setPhoneNumber("01234 567890")
print(student.returnNameAndMatrikel())
```

Mit `get...()` geben wir einen Wert zur√ºck, mit `set...()` setzen wir einen neuen Wert. Das ist das klassische Prinzip von **Kapselung**.

!!! info "Warum Getter und Setter?"

    - Wir k√∂nnen Werte auf G√ºltigkeit √ºberpr√ºfen, bevor sie gespeichert werden.
    - Wir behalten die Kontrolle, was ein Objekt √ºber sich preisgibt oder ver√§ndern darf.
    - Wir k√∂nnen die interne Struktur sp√§ter √§ndern, ohne das Hauptprogramm anpassen zu m√ºssen.

## üìÖ Zusammenfassung

| Begriff       | Bedeutung                                                                          |
| ------------- | ---------------------------------------------------------------------------------- |
| Attribut      | Ein Wert, der zu einem Objekt geh√∂rt, z.‚ÄØB. `self.name` oder `self.__stand`.       |
| privat        | Ein Attribut, das durch zwei Unterstriche gesch√ºtzt ist (`__stand`).               |
| Getter/Setter | Methoden, die Werte eines Attributs zur√ºckgeben oder setzen.                       |
| Kapselung     | Das Prinzip, Daten im Objekt zu halten und nur √ºber Methoden zug√§nglich zu machen. |
